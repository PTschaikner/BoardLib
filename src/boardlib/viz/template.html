<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Scatterplot with Zoom and Pan</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }

        svg {
            background-color: #f0f0f0;
            margin: 20px;
        }

        .axis text {
            font-size: 12px;
        }
    </style>
</head>

<body>
    <h1>D3 Scatterplot Example with Zoom and Pan</h1>
    <div>
        <label for="view">View: </label>
        <select id="view">
            <option value="daily">Daily</option>
            <option value="weekly">Weekly</option>
            <option value="monthly">Monthly</option>
            <option value="yearly">Yearly</option>
        </select>
    </div>
    <svg id="scatterplot" width="800" height="500"></svg>

    <!-- Embed D3.js Library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Embed your data -->
    <script id="data-script">
        const data = __DATA__;

        const margin = { top: 40, right: 20, bottom: 50, left: 50 };
        const scatterplotWidth = 800 - margin.left - margin.right;
        const scatterplotHeight = 500 - margin.top - margin.bottom;

        const svg = d3.select("#scatterplot")
            .attr("viewBox", `0 0 800 500`)
            .attr("preserveAspectRatio", "xMidYMid meet");

        svg.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("x", 0)
            .attr("y", -20)  // Add padding at the top
            .attr("width", scatterplotWidth)
            .attr("height", scatterplotHeight + 20); // Increase height to include the padding

        // Get the background color of the svg element
        const backgroundColor = window.getComputedStyle(document.querySelector("svg")).backgroundColor;

        // Define gradient for the fading effect
        const gradient = svg.append("defs").append("linearGradient")
            .attr("id", "fade-gradient")
            .attr("x1", "0%").attr("y1", "0%")
            .attr("x2", "100%").attr("y2", "0%");

        gradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", backgroundColor)
            .attr("stop-opacity", 1);

        gradient.append("stop")
            .attr("offset", "5%")
            .attr("stop-color", backgroundColor)
            .attr("stop-opacity", 0);

        // Group for axes
        const gAxis = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Group for points and lines with clip path
        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`)
            .attr("clip-path", "url(#clip)");

        // Add rectangle with gradient to create fading effect on edges
        svg.append("rect")
            .attr("x", margin.left + 1)
            .attr("y", margin.top - 5)
            .attr("width", scatterplotWidth)
            .attr("height", scatterplotHeight + 5)
            .style("fill", "url(#fade-gradient)")
            .style("pointer-events", "none");

        const x = d3.scaleTime().range([0, scatterplotWidth]);
        const y = d3.scaleLinear().range([scatterplotHeight, 0]);

        const formatDate = {
            daily: d3.timeFormat("%Y-%m-%d"),
            weekly: d3.timeFormat("%Y-%W"),
            monthly: d3.timeFormat("%Y-%m"),
            yearly: d3.timeFormat("%Y")
        };

        const processRoutes = (data) => {
            return data.map(d => ({
                date: new Date(d.date),
                grade: +d.difficulty,
                key: `${d.climb_name}-${d.date}`,
                is_ascent: d.is_ascent,
            }));
        };

        const routeData = processRoutes(data);

        const applyForceSimulation = (data, y, collisionRadius) => {
            const simulation = d3.forceSimulation(data)
                .force("x", d3.forceX(d => x(d.date)).strength(0.1))
                .force("y", d3.forceY(d => y(d.grade)).strength(1))
                .force("collision", d3.forceCollide(collisionRadius))
                .stop();

            for (let i = 0; i < 120; i++) {
                simulation.tick();
            }

            data.forEach(d => {
                d.fx = d.x;
                d.fy = d.y;
            });
        };


        const calculateTrendData = (data, transformDate) => {
            const filteredData = data.filter(d => d.is_ascent); // Use only ascents for trend calculation
            const groupedData = d3.group(filteredData, d => +transformDate(d.date));

            const avgTrendData = Array.from(groupedData, ([date, routes]) => {
                const avgGrade = d3.median(routes, d => d.grade);
                return { date: new Date(date), avgGrade: avgGrade };
            }).filter(d => !isNaN(d.avgGrade));

            const maxTrendData = Array.from(groupedData, ([date, routes]) => {
                const maxGrade = d3.max(routes, d => d.grade);
                return { date: new Date(date), maxGrade: maxGrade };
            }).filter(d => !isNaN(d.maxGrade));

            return { avgTrendData, maxTrendData };
        };

        const initialDrawCircles = (svg, data, y) => {
            const dotGroups = svg.selectAll(".dot-group")
                .data(data, d => d.key);

            // Handle entering elements
            const dotsEnter = dotGroups.enter().append("g")
                .attr("class", "dot-group");

            dotsEnter.append("circle")
                .attr("class", "dot")
                .attr("r", 3)
                .attr("opacity", 0.3)
                .attr("date", d => d.date)
                .attr("cx", d => x(d.date))
                .attr("cy", scatterplotHeight) // Start from the bottom
                .attr("stroke", "white")
                .transition()
                .duration(1000)
                .attr("fill", d => d.is_ascent ? "red" : "gray")
                .attr("cy", d => d.fy);
        };

        const drawCircles = (svg, data, y) => {
            const dotGroups = svg.selectAll(".dot-group")
                .data(data, d => d.key);

            // Handle exiting elements
            dotGroups.exit().transition()
                .duration(1000)
                .attr("opacity", 0)
                .remove();

            // Handle updating elements
            dotGroups.select("circle")
                .transition()
                .duration(1000)
                .attr("cx", d => d.fx)
                .attr("cy", d => d.fy)
                .attr("fill", d => d.is_ascent ? "red" : "gray");
        };

        const drawTrendlines = (svg, avgTrendData, maxTrendData, x, y) => {
            const avgTrendline = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.avgGrade))
                .curve(d3.curveBasis);

            const maxTrendline = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.maxGrade))
                .curve(d3.curveBasis);

            svg.selectAll(".avg-trendline").remove();
            svg.selectAll(".max-trendline").remove();

            svg.append("path")
                .datum(avgTrendData)
                .attr("class", "trendline avg-trendline")
                .attr("d", avgTrendline)
                .attr("stroke", "blue")
                .attr("fill", "none");

            svg.append("path")
                .datum(maxTrendData)
                .attr("class", "trendline max-trendline")
                .attr("d", maxTrendline)
                .attr("stroke", "red")
                .attr("fill", "none");

            // Define the area generator
            const area = d3.area()
                .x(d => x(d.date))
                .y0(d => y(d.avgGrade))
                .y1(d => y(d.maxGrade))
                .curve(d3.curveBasis);

            svg.selectAll(".area-between").remove();

            // Append the area path
            svg.append("path")
                .datum(avgTrendData.map((d, i) => ({
                    date: d.date,
                    avgGrade: d.avgGrade,
                    maxGrade: maxTrendData[i]?.maxGrade // Assuming avgTrendData and maxTrendData have the same length and matching dates
                })))
                .attr("class", "area-between")
                .attr("d", area)
                .attr("fill", "lightblue")
                .attr("opacity", 0.5);
        };

        let currentView = 'monthly';

        const updateAxes = (view, x, gAxis) => {
            const xAxis = d3.axisBottom(x)
                .tickFormat(formatDate[view])
                .ticks({
                    daily: d3.timeDay,
                    weekly: d3.timeWeek,
                    monthly: d3.timeMonth,
                    yearly: d3.timeYear
                }[view].every(1));

            const xAxisGroup = gAxis.select(".x.axis");
            if (xAxisGroup.empty()) {
                gAxis.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(0,${scatterplotHeight})`)
                    .call(xAxis)
                    .selectAll("text")
                    .style("text-anchor", "end")
                    .attr("dx", "-0.8em")
                    .attr("dy", "0.15em")
                    .attr("transform", "rotate(-45)");
            } else {
                xAxisGroup.call(xAxis)
                    .selectAll("text")
                    .style("text-anchor", "end")
                    .attr("dx", "-0.8em")
                    .attr("dy", "0.15em")
                    .attr("transform", "rotate(-45)");
            }
        };

        const updateData = (view, svg, data, y, yAxisStart) => {
            const transformDate = {
                daily: d3.timeDay,
                weekly: d3.timeWeek,
                monthly: d3.timeMonth,
                yearly: d3.timeYear
            }[view];

            const collisionRadius = {
                daily: 0.1,
                weekly: 0.5,
                monthly: 1,
                yearly: 2
            }[view]; // Adjust these values as needed

            const transformedData = data.map(d => ({
                ...d,
                date: transformDate(d.date)
            }));

            let xDomain = d3.extent(transformedData, d => d.date);
            const padding = (xDomain[1] - xDomain[0]) * 0.05;
            xDomain[0] = new Date(xDomain[0].getTime() - padding);
            xDomain[1] = new Date(xDomain[1].getTime() + padding);

            x.domain(xDomain);
            y.domain([yAxisStart, d3.max(transformedData, d => d.grade)]);

            applyForceSimulation(transformedData, y, collisionRadius);

            const { avgTrendData, maxTrendData } = calculateTrendData(transformedData, transformDate);

            drawTrendlines(svg, avgTrendData, maxTrendData, x, y);

            drawCircles(svg, transformedData, y);

            updateAxes(view, x, gAxis);

            const yAxis = d3.axisLeft(y);

            const yAxisGroup = gAxis.select(".y.axis");
            if (yAxisGroup.empty()) {
                gAxis.append("g")
                    .attr("class", "y axis")
                    .call(yAxis);
            } else {
                yAxisGroup.call(yAxis);
            }

            setTimeout(() => {
                svg.call(zoom.transform, d3.zoomIdentity);

                // Clear any stored zoom state
                zoom.transform(d3.select("#scatterplot"), d3.zoomIdentity);
            }, 1000); // Adjust the delay as needed
        };


        const initialSetup = (gAxis, g, data, y, yAxisStart) => {
            let xDomain = d3.extent(data, d => d.date);
            const padding = (xDomain[1] - xDomain[0]) * 0.05;
            xDomain[0] = new Date(xDomain[0].getTime() - padding);
            xDomain[1] = new Date(xDomain[1].getTime() + padding);

            x.domain(xDomain);
            y.domain([yAxisStart, d3.max(data, d => d.grade)]);

            updateAxes(currentView, x, gAxis);

            gAxis.append("g")
                .attr("class", "y axis")
                .call(d3.axisLeft(y));

            initialDrawCircles(g, data, y);
        };

        const zoomed = (event) => {
            const transform = event.transform;
            const newX = transform.rescaleX(x);

            updateAxes(currentView, newX, gAxis);

            g.selectAll(".dot")
                .attr("cx", d => transform.applyX(d.fx))
                .attr("cy", d => d.fy); // Keep y-coordinates fixed

            g.selectAll(".avg-trendline")
                .attr("d", d3.line()
                    .x(d => transform.applyX(x(d.date)))
                    .y(d => y(d.avgGrade)) // Keep y-coordinates fixed
                    .curve(d3.curveBasis)(g.selectAll(".avg-trendline").datum()));

            g.selectAll(".max-trendline")
                .attr("d", d3.line()
                    .x(d => transform.applyX(x(d.date)))
                    .y(d => y(d.maxGrade)) // Keep y-coordinates fixed
                    .curve(d3.curveBasis)(g.selectAll(".max-trendline").datum()));

            // Update the area path on zoom
            g.selectAll(".area-between")
                .attr("d", d3.area()
                    .x(d => transform.applyX(x(d.date)))
                    .y0(d => y(d.avgGrade))
                    .y1(d => y(d.maxGrade))
                    .curve(d3.curveBasis)(g.selectAll(".area-between").datum()));
        };

        const zoom = d3.zoom()
            .scaleExtent([1, 10])
            .translateExtent([[-100, -100], [scatterplotWidth + 100, scatterplotHeight + 100]])
            .on("zoom", zoomed);

        svg.call(zoom);

        document.getElementById("view").addEventListener("change", function () {
            currentView = this.value;
            updateData(currentView, g, routeData, y, 0);
        });
        initialSetup(gAxis, g, routeData, y, 0);
        updateData(currentView, g, routeData, y, 0);
    </script>
</body>

</html>
